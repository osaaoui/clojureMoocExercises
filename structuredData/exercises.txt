 Exercise 1

 The following function does a thing:

 (defn do-a-thing [x]
   (Math/pow (+ x x) (+ x x)))

   Change the function do-a-thing so that it uses let to give a name to the common expression (+ x x) in its body. 

(defn do-a-thing[x]
        (let [ex (+ x x)]
                  (Math/pow ex ex)))
 

  Exercise 2

  Write the function (spiff v) that takes a vector and returns the sum of the first and third elements of the vector. What happens when you pass in a vector that is too short?

  (spiff [1 2 3])       ;=> 4
  (spiff [1 2 3 4 5 6]) ;=> 4
  (spiff [1 2])         ;=> ?
  (spiff [])            ;=> ?

  (defn spiff [v]
     (+ (get v 0)(get v 2)))


 Exercise 3

 Write the function (cutify v) that takes a vector as a parameter and adds "<3" to its end.

 (cutify []) => ["<3"]
 (cutify [1 2 3]) => [1 2 3 "<3"]
 (cutify ["a" "b"]) => ["a" "b" "<3"]

 (defn cutify [v]
         (conj v "<3"))

 Exercise 4
 Rewrite our earlier function spiff by destructuring its parameter. Call this new function spiff-destructuring. 

 (defn spiff-destructuring [v]
         (let [[x y] [(get v 0) (get v 2)]]
                 (str x y)))

You can destructure function parameters directly. For an example, take the following function:

(defn sum-pairs [first-pair second-pair]
  [(+ (first  first-pair) (first  second-pair))
     (+ (second first-pair) (second second-pair))])

     The function takes two vectors and sums the elements pairwise:

     (sum-pairs [42 5]   [-42 -5])   ;=> [0 0]
     (sum-pairs [64 256] [-51 -219]) ;=> [13 37]

     sum-pair is not very pretty to look at. We can spiff it up by taking out the elements of its parameter vectors by destructuring them:

     (defn sum-pairs [[x1 y1] [x2 y2]]
       [(+ x1 x2) (+ y1 y2)])

